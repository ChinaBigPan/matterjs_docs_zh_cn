(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{359:function(t,e,v){"use strict";v.r(e);var _=v(43),o=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"composites"}},[t._v("Composites")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://brm.io/matter-js/docs/classes/Composites.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("英文原地址"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("code",[t._v("Matter.Composites")]),t._v("模块包含了用于创建具有常用配置(如堆栈和链)复合体的工厂方法。")]),t._v(" "),v("h2",{attrs:{id:"方法"}},[t._v("方法")]),t._v(" "),v("h4",{attrs:{id:"matter-composites-car-xx-yy-width-height-wheelsize-→-composite"}},[t._v("Matter.Composites.car(xx, yy, width, height, wheelSize) → Composite")]),t._v(" "),v("p",[t._v("使用简单的车型(car)物体和限制条件创建复合体。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("xx")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yy")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("width")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("height")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("wheelSize")]),t._v(" Number")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 复合体车身。")]),t._v(" "),v("h3",{attrs:{id:"matter-composites-chain-composite-xoffseta-yoffseta-xoffsetb-yoffsetb-options-→-composite"}},[t._v("Matter.Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) → Composite")]),t._v(" "),v("p",[t._v("使用约束条件将传入的复合体串连在一起形成链条。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("composite")]),t._v(" Composite"),v("br"),t._v(" "),v("code",[t._v("xOffsetA")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yOffsetA")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("xOffsetB")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yOffsetB")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("options")]),t._v(" Object")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 带约束条件的复合体链条。")]),t._v(" "),v("h3",{attrs:{id:"matter-composites-mesh-composite-columns-rows-crossbrace-options-→-composite"}},[t._v("Matter.Composites.mesh(composite, columns, rows, crossBrace, options) → Composite")]),t._v(" "),v("p",[t._v("将复合体中的刚体以某种限制条件组合成网状结构，可选是否带有交叉支架。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("composite")]),t._v(" Composite"),v("br"),t._v(" "),v("code",[t._v("columns")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rows")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("crossBrace")]),t._v(" Boolean"),v("br"),t._v(" "),v("code",[t._v("options")]),t._v(" Object")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 带有约束条件的网状结构复合体。")]),t._v(" "),v("h3",{attrs:{id:"matter-composites-newtonscradle-xx-yy-number-size-length-→-composite"}},[t._v("Matter.Composites.newtonsCradle(xx, yy, number, size, length) → Composite")]),t._v(" "),v("p",[t._v("将复合体中的刚体以某种限制条件组成牛顿摆(Newton's Cradle)。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("xx")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yy")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("number")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("size")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("length")]),t._v(" Number")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 牛顿摆复合体。")]),t._v(" "),v("h3",{attrs:{id:"matter-composites-pyramid-xx-yy-columns-rows-columngap-rowgap-callback-→-composite"}},[t._v("Matter.Composites.pyramid(xx, yy, columns, rows, columnGap, rowGap, callback) → Composite")]),t._v(" "),v("p",[t._v("创建一个新的复合体，它排成金字塔形状。该函数通过物体的边界来防止重叠。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("xx")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yy")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("columns")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rows")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("columnGap")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rowGap")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("callback")]),t._v(" Function")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 包含了在回调中创建的对象的新复合体。")]),t._v(" "),v("h3",{attrs:{id:"matter-composites-softbody-xx-yy-columns-rows-columngap-rowgap-crossbrace-particleradius-particleoptions-constraintoptions-→-composite"}},[t._v("Matter.Composites.softBody(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) → Composite")]),t._v(" "),v("p",[t._v("创建一个简单的柔体。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("xx")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yy")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("columns")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rows")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("columnGap")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rowGap")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("crossBrace")]),t._v(" Boolean\n"),v("code",[t._v("particleRadius")]),t._v(" Number\n"),v("code",[t._v("particleOptions")]),t._v(" Object\n"),v("code",[t._v("constraintOptions")]),t._v(" Object")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 新的复合柔体。")]),t._v(" "),v("h3",{attrs:{id:"matter-composites-stack-xx-yy-columns-rows-columngap-rowgap-callback-→-composite"}},[t._v("Matter.Composites.stack(xx, yy, columns, rows, columnGap, rowGap, callback) → Composite")]),t._v(" "),v("p",[t._v("创建一个新的复合体，在创建的回调函数中将其包含的刚体排成堆的形状。该函数通过物体的边界来防止重叠。")]),t._v(" "),v("p",[t._v("参数：")]),t._v(" "),v("p",[v("code",[t._v("xx")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("yy")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("columns")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rows")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("columnGap")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("rowGap")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("callback")]),t._v(" Function")]),t._v(" "),v("p",[t._v("返回值：")]),t._v(" "),v("p",[v("code",[t._v("Composite")]),t._v(" 包含了在回调中创建的对象的新复合体。")]),t._v(" "),v("h1",{attrs:{id:"matter-constraint"}},[t._v("Matter.Constraint")]),t._v(" "),v("p",[v("code",[t._v("Matter.Constraint")]),t._v("模块包含了创建和操作约束条件的方法。约束条件用于指定两个物体之间(或者一个物体和世界固定坐标)必须保持固定的距离。约束条件既可以是刚性的也可以是弹性的。")]),t._v(" "),v("h2",{attrs:{id:"方法-2"}},[t._v("方法")]),t._v(" "),v("h3",{attrs:{id:"matter-constraint-create-options-→-constraint"}},[t._v("Matter.Constraint.create(options) → Constraint")]),t._v(" "),v("p",[t._v("创建一个新的约束条件。所有属性都有默认值，而且许多属性都是基于其他属性预先计算的。比方说为了模拟一个可以转动的关节，可以将长度设置为"),v("code",[t._v("0")]),t._v("并且设置一个较高的"),v("code",[t._v("stiffness")]),t._v("值(例如 "),v("code",[t._v("0.7")]),t._v("以上)。如果约束条件不稳定，可以尝试降低"),v("code",[t._v("stiffness")]),t._v("值和/或增加"),v("code",[t._v("engine.constraintIterations")]),t._v("。对于复合体，约束条件必须应用于父级(而不是它的某个子元素部分)。"),v("code",[t._v("options")]),t._v("配置项可以设置哪些属性，请参见后文。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("options")]),t._v(" Object")]),t._v(" "),v("p",[t._v("返回值："),v("br"),t._v(" "),v("code",[t._v("Constraint")]),t._v(" constraint")]),t._v(" "),v("h2",{attrs:{id:"属性"}},[t._v("属性")]),t._v(" "),v("p",[t._v("下面的属性均是在"),v("code",[t._v("Matter.Constraint.create")]),t._v("创建时就设置好，且可以通过传递的"),v("code",[t._v("options")]),t._v("参数进行覆盖。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("属性")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("类型")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("默认值")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.bodyA")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Body")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("null")])]),t._v(" "),v("td",[t._v("施加约束条件的第一个可能的物体。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.bodyB")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Body")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("null")])]),t._v(" "),v("td",[t._v("施加约束条件的第二个可能的物体。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.damping")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Number")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("0")])]),t._v(" "),v("td",[t._v("表示约束阻尼的"),v("code",[t._v("数字")]),t._v("，即基于物体的速度施加到每个物体上从而限制振动量的阻力。只有当约束条件的刚性度(stiffness)也很低时，阻尼才会明显地表示出来。该值为"),v("code",[t._v("0.1")]),t._v("时表示约束阻尼较重，从而使震动不明显甚至没有震动。若为"),v("code",[t._v("0")]),t._v("则表示没有阻尼。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.id")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Number")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("独一无二的数字标识符，由"),v("code",[t._v("Composite.create")]),t._v("通过"),v("code",[t._v("Common.nextId")]),t._v("生成。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.label")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v('"Constraint"')])]),t._v(" "),v("td",[t._v("于帮助用户识别和管理复合体的任意"),v("code",[t._v("String")]),t._v("名称。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.plugin")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("为存储插件专用属性而保留的对象。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.pointA")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Vector")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("{ x: 0, y: 0 }")])]),t._v(" "),v("td",[t._v("如果定义了约束条件，那么它就是表示从"),v("code",[t._v("constraint.bodyA")]),t._v("中开始的约束偏移量，否则的话为其在世界坐标中的位置。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.pointB")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Vector")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("{ x: 0, y: 0 }")])]),t._v(" "),v("td",[t._v("如果定义了约束条件，那么它就是表示从"),v("code",[t._v("constraint.bodyB")]),t._v("中开始的约束偏移量，否则的话为其在世界坐标中的位置。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.render")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Object")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("定义"),v("code",[t._v("Matter.Render")]),t._v("模块使用的渲染属性的对象。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.render.anchors")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Boolean")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("true")])]),t._v(" "),v("td",[t._v("表示是否渲染约束锚点。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.render.lineWidth")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("2")])]),t._v(" "),v("td",[t._v("表示渲染约束外框时的线宽。值为"),v("code",[t._v("0")]),t._v("时表示不渲染。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.render.strokeStyle")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("随机颜色")])]),t._v(" "),v("td",[t._v("在渲染时使用的外框样式。这点和"),v("code",[t._v("canvas")]),t._v("相一致，因此也接受CSS样式字符串。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.render.type")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("'line'")])]),t._v(" "),v("td",[t._v('定义约束渲染类型的字符串。可能的值为"line"、"pin"、"spring"。若没有在配置项中设置，将自动选择合适的渲染类型。')])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.render.visible")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Boolean")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("true")])]),t._v(" "),v("td",[t._v("表示是否渲染约束条件。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.stiffness")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("1")])]),t._v(" "),v("td",[t._v("指定约束条件刚性程度的数字，即它返回到静约束长度的速率。值为"),v("code",[t._v("1")]),t._v("以为着约束非常严格。值为"),v("code",[t._v("0.2")]),t._v("差不多类似于软弹簧。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("constraint.type")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v('constraint"')])]),t._v(" "),v("td",[t._v("表示对象类型的字符串。")])])])])])}),[],!1,null,null,null);e.default=o.exports}}]);