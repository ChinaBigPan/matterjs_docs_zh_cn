(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{356:function(o,t,v){"use strict";v.r(t);var e=v(43),s=Object(e.a)({},(function(){var o=this,t=o.$createElement,v=o._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[v("h1",{attrs:{id:"bounds"}},[o._v("Bounds")]),o._v(" "),v("p",[v("a",{attrs:{href:"https://brm.io/matter-js/docs/classes/Bounds.html",target:"_blank",rel:"noopener noreferrer"}},[o._v("英文原地址"),v("OutboundLink")],1)]),o._v(" "),v("p",[v("code",[o._v("Matter.Bounds")]),o._v("模块用于创建和操作轴对其边框(AABB盒)的方法。")]),o._v(" "),v("h2",{attrs:{id:"方法"}},[o._v("方法")]),o._v(" "),v("h3",{attrs:{id:"matter-bounds-contains-bounds-point-→-boolean"}},[o._v("Matter.Bounds.contains(bounds, point) → Boolean")]),o._v(" "),v("p",[o._v("如果边框包含传入的点，则返回"),v("code",[o._v("true")]),o._v("。")]),o._v(" "),v("p",[v("strong",[o._v("参数：")]),v("br"),o._v(" "),v("code",[o._v("bounds")]),o._v(" Bounds"),v("br"),o._v(" "),v("code",[o._v("point")]),o._v(" Vector")]),o._v(" "),v("p",[v("strong",[o._v("返回值：")]),v("br"),o._v("\nBoolean 如果边框包含传入的点返回"),v("code",[o._v("true")]),o._v("，否则返回"),v("code",[o._v("false")])]),o._v(" "),v("h3",{attrs:{id:"matter-bounds-create-vertices-→-bounds"}},[o._v("Matter.Bounds.create(vertices) → Bounds")]),o._v(" "),v("p",[o._v("在传入的顶点处创建一个新的周对其边界框(AABB盒)。")]),o._v(" "),v("p",[v("strong",[o._v("参数：")]),v("br"),o._v(" "),v("code",[o._v("vertices")]),o._v(" Vertices")]),o._v(" "),v("p",[v("strong",[o._v("返回值：")]),v("br"),o._v("\nBounds 新的边界对象。")]),o._v(" "),v("h3",{attrs:{id:"matter-bounds-overlaps-boundsa-boundsb-→-boolean"}},[o._v("Matter.Bounds.overlaps(boundsA, boundsB) → Boolean")]),o._v(" "),v("p",[o._v("如果两个边界(boundsA和boundsB)相交则返回"),v("code",[o._v("true")]),o._v("。")]),o._v(" "),v("p",[v("strong",[o._v("参数：")]),v("br"),o._v(" "),v("code",[o._v("boundsA")]),o._v(" Bounds"),v("br"),o._v(" "),v("code",[o._v("boundsB")]),o._v(" Bounds")]),o._v(" "),v("p",[v("strong",[o._v("返回值：")]),v("br"),o._v("\nBoolean  如果重叠则返回"),v("code",[o._v("true")]),o._v("，否则返回"),v("code",[o._v("false")]),o._v("。")]),o._v(" "),v("h3",{attrs:{id:"matter-bounds-shift-bounds-position"}},[o._v("Matter.Bounds.shift(bounds, position)")]),o._v(" "),v("p",[o._v("将边界移动到指定位置。")]),o._v(" "),v("p",[v("strong",[o._v("参数：")]),v("br"),o._v(" "),v("code",[o._v("bounds")]),o._v(" Bounds"),v("br"),o._v(" "),v("code",[o._v("position")]),o._v(" Vector")]),o._v(" "),v("h3",{attrs:{id:"matter-bounds-translate-bounds-vector"}},[o._v("Matter.Bounds.translate(bounds, vector)")]),o._v(" "),v("p",[o._v("通过传入的矢量来移动边界。")]),o._v(" "),v("p",[v("strong",[o._v("参数：")]),v("br"),o._v(" "),v("code",[o._v("bounds")]),o._v(" Bounds"),v("br"),o._v(" "),v("code",[o._v("position")]),o._v(" Vector")]),o._v(" "),v("h3",{attrs:{id:"matter-bounds-update-bounds-vertices-velocity"}},[o._v("Matter.Bounds.update(bounds, vertices, velocity)")]),o._v(" "),v("p",[o._v("使用传入的顶点更新边界，并根据传入的速度扩展边界。")]),o._v(" "),v("p",[v("strong",[o._v("参数：")]),v("br"),o._v(" "),v("code",[o._v("bounds")]),o._v(" Bounds"),v("br"),o._v(" "),v("code",[o._v("vertices")]),o._v("  Vertices"),v("br"),o._v(" "),v("code",[o._v("velocity")]),o._v("  Vector")])])}),[],!1,null,null,null);t.default=s.exports}}]);