(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{355:function(t,e,v){"use strict";v.r(e);var _=v(43),d=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"body"}},[t._v("Body")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://brm.io/matter-js/docs/classes/Body.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("英文原地址"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("code",[t._v("Matter.Body")]),t._v("模块包含用于创建和操作刚体(body)模型的方法。"),v("code",[t._v("Matter.Body")]),t._v("是可以用"),v("code",[t._v("Matter.Engine")]),t._v("进行模拟的刚体。通常使用的刚体配置(如矩形、圆形和其他多边形)可以在"),v("code",[t._v("Matter.Bodies")]),t._v("中找到。")]),t._v(" "),v("h2",{attrs:{id:"方法"}},[t._v("方法")]),t._v(" "),v("h3",{attrs:{id:"matter-body-applyforce-body-position-force"}},[t._v("Matter.Body.applyForce(body, position, force)")]),t._v(" "),v("p",[t._v("从传入的世界坐标位置给刚体一个力，包括产生的力矩。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("position")]),t._v(" Vector"),v("br"),t._v(" "),v("code",[t._v("force")]),t._v(" Vector")]),t._v(" "),v("h3",{attrs:{id:"matter-body-create-options-→-body"}},[t._v("Matter.Body.create(options) → Body")]),t._v(" "),v("p",[t._v("创建一个新的刚体模型。"),v("code",[t._v("options")]),t._v("参数是一个对象，用以设置需要覆盖默认值的属性。所有的属性都有默认值，而且许多都是基于其他属性预先计算。顶点(Vertices)必须按照顺指针顺序指定。后面会介绍"),v("code",[t._v("options")]),t._v("可以设置的属性。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("options")]),t._v(" Object")]),t._v(" "),v("p",[t._v("返回值："),v("br"),t._v(" "),v("code",[t._v("Body")]),t._v(" body")]),t._v(" "),v("h3",{attrs:{id:"matter-body-nextcategory-→-number"}},[t._v("Matter.Body.nextCategory() → Number")]),t._v(" "),v("p",[t._v("返回下一个唯一类别位字段(从初始默认类别"),v("code",[t._v("0x0001")]),t._v("开始)。参见"),v("code",[t._v("body.collisionFilter")]),t._v("以了解更多。")]),t._v(" "),v("p",[t._v("返回值："),v("br"),t._v(" "),v("code",[t._v("Number")]),t._v(" 唯一类别位字段。")]),t._v(" "),v("h3",{attrs:{id:"matter-body-nextgroup-isnoncolliding-false-→-number"}},[t._v("Matter.Body.nextGroup([isNonColliding=false]) → Number")]),t._v(" "),v("p",[t._v("返回将发生碰撞的刚体的下一个唯一组索引。如果"),v("code",[t._v("isNonColliding")]),t._v("设置为"),v("code",[t._v("true")]),t._v("，则返回的就是不会发生碰撞的下一个唯一组索引。参见"),v("code",[t._v("body.collisionFilter")]),t._v("以了解更多。")]),t._v(" "),v("p",[t._v("参见："),v("br"),t._v(" "),v("code",[t._v("[isNonColliding=false]")]),t._v(" Bool 可选")]),t._v(" "),v("p",[t._v("返回值：\n"),v("code",[t._v("Number")]),t._v(" 唯一组索引")]),t._v(" "),v("h3",{attrs:{id:"matter-body-rotate-body-rotation-point"}},[t._v("Matter.Body.rotate(body, rotation, [point])")]),t._v(" "),v("p",[t._v("使物体相对于它当前的角度旋转传入的角度，而不产生任何角速度。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body\n"),v("code",[t._v("rotation")]),t._v(" Number\n"),v("code",[t._v("[point]")]),t._v(" Vector 可选")]),t._v(" "),v("h3",{attrs:{id:"matter-body-scale-body-scalex-scaley-point"}},[t._v("Matter.Body.scale(body, scaleX, scaleY, [point])")]),t._v(" "),v("p",[t._v("根据世界坐标点缩放刚体中的所有子元素，物理属性(质量、面积、轴、惯性)也包含在内。")]),t._v(" "),v("p",[t._v("参数：\n"),v("code",[t._v("body")]),t._v(" Body\n"),v("code",[t._v("scaleX")]),t._v(" Number\n"),v("code",[t._v("scaleY")]),t._v(" Number\n"),v("code",[t._v("[point]")]),t._v(" Vector 可选")]),t._v(" "),v("h3",{attrs:{id:"matter-body-set-body-settings-value"}},[t._v("Matter.Body.set(body, settings, value)")]),t._v(" "),v("p",[t._v("传入属性和值(或映射)并设置到刚体上，如果存在合适的 setter\n函数则会使用。如果出现性能上的要求请使用实际的 setter 方法。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("settings")]),t._v(" Object - 要在刚体上设置的属性名称(或属性和值的映射)。"),v("br"),t._v(" "),v("code",[t._v("value")]),t._v(" Object - 如果"),v("code",[t._v("settings")]),t._v("是单个属性名称，那么就设置这个值。")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setangle-body-angle"}},[t._v("Matter.Body.setAngle(body, angle)")]),t._v(" "),v("p",[t._v("立即设置刚体的角度。角速度、位置、力等不变。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("angle")]),t._v(" Number")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setangularvelocity-body-velocity"}},[t._v("Matter.Body.setAngularVelocity(body, velocity)")]),t._v(" "),v("p",[t._v("设置刚体的角速度。位置、角度。力等不变。请参照"),v("code",[t._v("Body.applyForce")]),t._v("。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("velocity")]),t._v(" Number")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setdensity-body-density"}},[t._v("Matter.Body.setDensity(body, density)")]),t._v(" "),v("p",[t._v("设置刚体的密度。质量和惯性会自动更新以反映变化。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("density")]),t._v(" Number")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setinertia-body-inertia"}},[t._v("Matter.Body.setInertia(body, inertia)")]),t._v(" "),v("p",[t._v("设置物体的惯性矩(moment of inertia，即截面惯性矩)。反向惯性会自动更新以反映变化。质量不变。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("inertia")]),t._v(" Number")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setmass-body-mass"}},[t._v("Matter.Body.setMass(body, mass)")]),t._v(" "),v("p",[t._v("设置刚体的质量。反向质量、密度和惯性会自动更新以反映变化。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("mass")]),t._v(" Number")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setparts-body-body-autohull-true"}},[t._v("Matter.Body.setParts(body, [body], [autoHull=true])")]),t._v(" "),v("p",[t._v("设置刚体的部件并更新质量、惯性和质心。每个部件都将其父元素设置为该刚体。默认情况下，"),v("a",{attrs:{href:"https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150?fromtitle=Convex%20Hull&fromid=18082147&fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("凸包算法(convex hull)"),v("OutboundLink")],1),t._v("会自动计算并在刚体上设置，除非"),v("code",[t._v("autoHull")]),t._v("设置为"),v("code",[t._v("false")]),t._v("。注意，该方法将确保"),v("code",[t._v("body.parts")]),t._v("的第一个部件总是为刚体本身。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("[body]")]),t._v(" Object 可选\n"),v("code",[t._v("[autoHull=true]")]),t._v(" Bool 可选")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setposition-body-position"}},[t._v("Matter.Body.setPosition(body, position)")]),t._v(" "),v("p",[t._v("立即设置刚体的位置。速度、角度、力等不变。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("position")]),t._v(" Vector")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setstatic-body-isstatic"}},[t._v("Matter.Body.setStatic(body, isStatic)")]),t._v(" "),v("p",[t._v("将刚体设置为静态，包括其"),v("code",[t._v("isStatic")]),t._v("项，并将质量和惯性设置为无穷大。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("isStatic")]),t._v(" Bool")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setvelocity-body-velocity"}},[t._v("Matter.Body.setVelocity(body, velocity)")]),t._v(" "),v("p",[t._v("立即设置刚体的线速度。位置、角度、力等不变。参见"),v("code",[t._v("Body.applyForce")]),t._v("。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("velocity")]),t._v(" Vector")]),t._v(" "),v("h3",{attrs:{id:"matter-body-setvertices-body-vertices"}},[t._v("Matter.Body.setVertices(body, vertices)")]),t._v(" "),v("p",[t._v("设置物体的顶点并相应地更新物体的属性。包括惯性、面积和质量(相对于"),v("code",[t._v("body.density")]),t._v(")。顶点将自动转换为围绕其质心作为原点的方向。然后它们会根据"),v("code",[t._v("body.position")]),t._v("自动转换空间坐标。")]),t._v(" "),v("p",[t._v("参数"),v("code",[t._v("vertices")]),t._v("应该传入"),v("code",[t._v("Matter.Vector")]),t._v("点的数组(或是"),v("code",[t._v("Matter.Vertices")]),t._v("数组)")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("vertices")]),t._v(" Vector[]")]),t._v(" "),v("h3",{attrs:{id:"matter-body-translate-body-translation"}},[t._v("Matter.Body.translate(body, translation)")]),t._v(" "),v("p",[t._v("相对于当前位置，根据给定的矢量来移动刚体，不产生任何速度。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("translation")]),t._v(" Vector")]),t._v(" "),v("h3",{attrs:{id:"matter-body-update-body-deltatime-timescale-correction"}},[t._v("Matter.Body.update(body, deltaTime, timeScale, correction)")]),t._v(" "),v("p",[t._v("对给定的刚体执行模拟步骤，包括更新位置和使用 Verlet 积分法更新角度。")]),t._v(" "),v("p",[t._v("参数："),v("br"),t._v(" "),v("code",[t._v("body")]),t._v(" Body"),v("br"),t._v(" "),v("code",[t._v("deltaTime")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("timeScale")]),t._v(" Number"),v("br"),t._v(" "),v("code",[t._v("correction")]),t._v(" Number")]),t._v(" "),v("h2",{attrs:{id:"属性"}},[t._v("属性")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("属性名")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("类型")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("默认值")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.angle")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("以弧度表示物体角度的"),v("strong",[t._v("数字")]),t._v("。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.angularSpeed")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("表示物体在上次"),v("code",[t._v("Body.update")]),t._v("后当前角速度的"),v("strong",[t._v("数字")]),t._v("。该数字为只读且永远为正(是"),v("code",[t._v("body.angularVelocity")]),t._v("值的量级)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.angularVelocity")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("用来表示物体在上次"),v("code",[t._v("Body.update")]),t._v("后的当前角速度的"),v("strong",[t._v("数字")]),t._v("。只读。如果您需要直接修改物体的角速度，那么您应该利用扭矩或改变物体的"),v("code",[t._v("angle")]),t._v("。(因为引擎使用了“位置-Verlet积分法”)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.area")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("表示物体凸包面积的数字，在"),v("code",[t._v("Body.create")]),t._v("创建时就计算好了。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.axes")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Vector[]")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("唯一的轴向量数组(边缘法线)，用于碰撞检测。在"),v("code",[t._v("Body.create")]),t._v("创建凸包时就已经计算完毕。它们会在模拟过程中随"),v("code",[t._v("Body.update")]),t._v("不断更新。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.bounds")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Bounds")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("为物体定义"),v("a",{attrs:{href:"https://baike.baidu.com/item/AABB%E7%9B%92/10087682?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("AABB盒"),v("OutboundLink")],1),t._v("的"),v("code",[t._v("Bounds")]),t._v("对象。它根据给定的凸包(顶点数组)在"),v("code",[t._v("Body.create")]),t._v("时自动计算，并在模拟过程中随"),v("code",[t._v("Body.update")]),t._v("不断更新。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.collisionFilter")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Object")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("指定碰撞过滤属性的对象。"),v("br"),v("br"),t._v("  物体之间的碰撞遵循如下规则："),v("br"),t._v(" · 如果两个物体拥有相同且不为"),v("code",[t._v("0")]),t._v("的"),v("code",[t._v("collisionFilter.group")]),t._v("值，那么值为正数的时候将总是处于碰撞状态，负值则不会碰撞。"),v("br"),t._v(" · 如果两个物体的"),v("code",[t._v("collisionFilter.group")]),t._v("值不相同，或是其中一个(或两个)的值为"),v("code",[t._v("0")]),t._v("那么，碰撞类别/掩码则适用如下规则："),v("br"),t._v(" "),v("br"),t._v(" 每个物体都属于一个碰撞类别，它由"),v("code",[t._v("collisionFilter.category")]),t._v("分配。该值用作位字段，并且碰撞类别应只有一个位集，这意味着该属性的值范围为"),v("code",[t._v("[1, 2^31]")]),t._v("内的2的平方。因此，我们可以使用"),v("code",[t._v("32")]),t._v("种不同类别的碰撞。"),v("br"),t._v(" "),v("br"),t._v(" 每个物体还由"),v("code",[t._v("collisionFilter.mask")]),t._v("定义了碰撞位掩码，以表示碰撞的类别(该值是所有这些类别位值的和值。)。"),v("br"),t._v(" "),v("br"),t._v(" 使用碰撞类别/掩码规则，如果刚体"),v("code",[t._v("A")]),t._v("和"),v("code",[t._v("B")]),t._v("各在其掩码中都包含了其他的类别。举例："),v("code",[t._v("(categoryA & maskB) !== 0")]),t._v("和"),v("code",[t._v("(categoryB & maskA) !== 0")]),t._v(" 均为"),v("code",[t._v("true")]),t._v("。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.collisionFilter.category")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Object")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),v("td",[t._v("表示物体的碰撞类别。它只有一个位集，例如："),v("code",[t._v("0x0001")]),t._v("。意味着我们可以使用多达"),v("code",[t._v("32")]),t._v("种独特的碰撞类别。参见"),v("code",[t._v("body.collisionFilter")]),t._v("了解更多信息。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.collisionFilter.group")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Object")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("整数，表示碰撞物体所属的碰撞组。参见"),v("code",[t._v("body.collisionFilter")]),t._v("了解更多信息。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.collisionFilter.mask")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Object")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("-1")]),t._v(" "),v("td",[t._v("位掩码，表示物体可能与之发生碰撞的碰撞类别。参见"),v("code",[t._v("body.collisionFilter")]),t._v("了解更多信息。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.density")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0.001")]),t._v(" "),v("td",[t._v("定义物体密度的数字，即物体在单位面积上的质量。如果您在"),v("code",[t._v("Body.create")]),t._v("时传了密度，那么"),v("code",[t._v("质量(mass)")]),t._v("属性会根据对象的大小(面积)自动计算。这种方法比单纯设置质量更好，且可以更直观地定义材料(比如，岩石的密度比木材要高。)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.force")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Vector")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("{ x: 0, y: 0 }")])]),t._v(" "),v("td",[t._v("表示在当前更新步骤中应用的力的矢量。每次"),v("code",[t._v("Body.update")]),t._v("会归零。请参阅"),v("code",[t._v("Body.applyForce")]),t._v("。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.friction")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0.1")]),t._v(" "),v("td",[t._v("表示物体摩擦力的数字。该值始终为正，且范围为"),v("code",[t._v("(0, 1)")]),t._v("。值为"),v("code",[t._v("0")]),t._v("表示物体可以无限滑动。值为"),v("code",[t._v("1")]),t._v("表示在施加一个力后，物体几乎可以立即静止。"),v("br"),v("br"),t._v(" 该值的影响可能是非线性的。根据物体的不同，即便是较大的值也可能不稳定。物理引擎采用的是库仑摩擦模型，它包括静态摩擦和动态摩擦。需要注意的是，碰撞响应应基于物体对，摩擦值应结合下面的公式："),v("br"),t._v(" "),v("code",[t._v("Math.min(bodyA.friction, bodyB.friction)")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.frictionAir")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0.01")]),t._v(" "),v("td",[t._v("表示物体空气摩擦力(空气阻力)的数字。值为"),v("code",[t._v("0")]),t._v("意味着物体在空间中运动时永远不会减速。这个值越高，物体在空间中减速得越快。该值的影响是非线性的。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.frictionStatic")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0.5")]),t._v(" "),v("td",[t._v("表示物体静摩擦力的数字(基于库伦摩擦模型)。若为"),v("code",[t._v("0")]),t._v("则意味着当它在几乎静止状态下，只使用动态"),v("code",[t._v("friction")]),t._v("时，它永远不会被“黏住”。数值越高(比方说"),v("code",[t._v("10")]),t._v("), 则首次使物体移动时所需要的力就越大。这个值与"),v("code",[t._v("friction")]),t._v("属性相乘，从而使改变"),v("code",[t._v("friction")]),t._v("和保持适当的静摩擦更加容易。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.id")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("在"),v("code",[t._v("Body.create")]),t._v("创建时就通过"),v("code",[t._v("Common.nextId")]),t._v("生成的唯一标识符。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.inertia")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("定义物体惯性矩(即截面二次轴矩)。在"),v("code",[t._v("Body.create")]),t._v("创建物体时通过凸包(顶点数组)和密度自动计算而成。如果要修改它，则还要修改"),v("code",[t._v("body.inverseInertia")]),t._v("属性("),v("code",[t._v("1/inertia")]),t._v(")。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.inverseInertia")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("定义物体的反惯性矩。如果要修改它，则还要修改"),v("code",[t._v("body.inertia")]),t._v("属性("),v("code",[t._v("1/inertia")]),t._v(")。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.inverseMass")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("定义物体质量的倒数("),v("code",[t._v("1/mass")]),t._v(")。如果修改此项，还必须修改"),v("code",[t._v("body.mass")]),t._v("属性。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.isSensor")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Boolean")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("false")])]),t._v(" "),v("td",[t._v("指示一个物体是否是传感器。传感器触发碰撞事件，但并不会与碰撞的物体做出物理反应。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.isSleeping")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Boolean")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("false")])]),t._v(" "),v("td",[t._v("表示物体是否处于睡眠状态。处于睡眠状态和静止状态类似，只不过它是暂时的，可以被唤醒。如果你需要将一个物体设置为睡眠状态。请使用"),v("code",[t._v("Sleeping.set")]),t._v("而非直接修改它。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.isStatic")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Boolean")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("false")])]),t._v(" "),v("td",[t._v("表示物体是否为静止状态。一个静止的物体永远不会改变位置或角度，它是完全固定的。如果您需要在创建物体后将其设置为静态，那么请使用"),v("code",[t._v("Body.setStatic")]),t._v("而非直接修改该值。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.label")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v('"Body"')]),t._v(" "),v("td",[t._v("帮助用户识别和管理物体的任意字符串名称。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.mass")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("定义物体质量的数字，虽然指定"),v("code",[t._v("密度density")]),t._v("属性可能更合适。如果要修改该值，请务必同时修改"),v("code",[t._v("body.inverseMass")]),t._v("属性(1/mass)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.motion")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("测量当前物体的移动量的数字(速度和角速度的组合)。它是只读且总为正数。在模拟过程中"),v("code",[t._v("Matter.Sleeping")]),t._v("模块通过使用和更新它来判断物体是否进入静止状态。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.parent")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Body")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("如果物体不是另一个物体的一部分的话，则表示物体自身。否则表示物体所属的父级。参见"),v("code",[t._v("body.parts")]),t._v("。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.parts")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Body[]")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("物体的数组。数组中的第一项是当前物体实例的自引用。"),v("code",[t._v("parts")]),t._v("中的所有物体组合成一个刚醒的复合体。物体可以重叠，拥有间隙或孔，形成凹体也没有问题。这些作为部件的物体永远不要添加到"),v("code",[t._v("World")]),t._v("中，所添加的应该是它的父级物体。使用"),v("code",[t._v("Body.setParts")]),t._v("来确保所有属性能正确更新。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.plugin")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("为存储插件特定属性而保留的对象。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.position")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Vector")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("{ x: 0, y: 0 }")])]),t._v(" "),v("td",[t._v("表示物体在当前世界坐标内位置的"),v("code",[t._v("矢量Vector")]),t._v("。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Object")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("模块"),v("code",[t._v("Matter.Render")]),t._v(" 使用的渲染属性的对象。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.fillStyle")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("随机颜色")])]),t._v(" "),v("td",[t._v("表示物体在渲染时使用的填充样式。这点和"),v("code",[t._v("canvas")]),t._v("相一致，因此也接受CSS样式字符串。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.lineWidth")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("表示物体在渲染时的线宽(如果没有定义"),v("code",[t._v("sprite")]),t._v("属性)。若值为"),v("code",[t._v("0")]),t._v("则表示不渲染外框。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.opacity")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),v("td",[t._v("渲染时的透明度。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.sprite")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Object")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("表示渲染时要使用的"),v("code",[t._v("sprite")]),t._v("属性(如果有的话)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.sprite.texture")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("表示"),v("code",[t._v("sprite")]),t._v("纹理图的图像路径(如果有的话)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.sprite.xOffset")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("表示"),v("code",[t._v("sprite")]),t._v("图X轴偏移量的数字(通过纹理宽度标准化)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.sprite.xScale")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),v("td",[t._v("表示"),v("code",[t._v("sprite")]),t._v("图X缩放量的数字(如果有的话)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.sprite.yOffset")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("表示"),v("code",[t._v("sprite")]),t._v("图Y轴偏移量的数字(通过纹理宽度标准化)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.sprite.yScale")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),v("td",[t._v("表示"),v("code",[t._v("sprite")]),t._v("图Y缩放量的数字(如果有的话)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.strokeStyle")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("随机颜色")])]),t._v(" "),v("td",[t._v("表示物体在渲染时使用的外框样式(如果没有定义"),v("code",[t._v("sprite")]),t._v("属性)。这点和"),v("code",[t._v("canvas")]),t._v("相一致，因此也接受CSS样式字符串。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.render.visible")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Boolean")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("true")])]),t._v(" "),v("td",[t._v("表示物体是否应渲染。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.restitution")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("定义物体的弹性。该值总是正值，范围"),v("code",[t._v("(0 , 1)")]),t._v("。值为"),v("code",[t._v("0")]),t._v("意味着碰撞不会发生任何反弹。设置为"),v("code",[t._v("0.8")]),t._v("的话意味着物体可以弹回大约80%的动能。注意碰撞响应基于"),v("code",[t._v("物体对 pairs of bodies")]),t._v("，弹性恢复值要结合以下公式："),v("br"),t._v(" Math.max(bodyA.restitution, bodyB.restitution)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.sleepThreshold")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("60")]),t._v(" "),v("td",[t._v("表示物体在被"),v("code",[t._v("Matter.Sleeping")]),t._v("模块设置为睡眠状态之前必须具有的接近于0的速度的次数(如果引擎启用了sleep的话)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.slop")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0.05")]),t._v(" "),v("td",[t._v("表示物体允许“下沉”或旋转到其他物体上的容忍度。除非您理解物理引擎中"),v("code",[t._v("slop")]),t._v("的作用，否则应该避免修改该值。默认值通常就够了，尽管非常大的物体可能需要更大的值才能稳定堆叠。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.speed")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("表示上次"),v("code",[t._v("Body.update")]),t._v("后的当前速度。该值为只读并且总是正值(它是"),v("code",[t._v("body.velocity")]),t._v("值的大小)。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.timeScale")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),v("td",[t._v("表示允许每个物体的时间缩放。例如，在一个立场中，内部物体是慢动作而其他物体是全速的。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.torque")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Number")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),v("td",[t._v("表示当前更新步骤中的扭矩(扭转力)。它会在每次"),v("code",[t._v("Body.update")]),t._v("后归零。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.type")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("String")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v('"body"')]),t._v(" "),v("td",[t._v("表示对象类型的字符串。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.velocity")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Vector")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("{ x: 0, y: 0 }")])]),t._v(" "),v("td",[t._v("表示上次"),v("code",[t._v("Body.update")]),t._v("后的当前速度的矢量。该项为只读。如果您要直接修改一个物体的速度，要么施加一个力，要么简单地改变物体的位置。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("body.vertices")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Vector[]")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",[t._v("表示刚体凸包的矢量对象数组。应传入原点"),v("code",[t._v("(0, 0)")]),t._v("，如下："),v("br"),t._v(" [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }] "),v("br"),t._v(" 当由"),v("code",[t._v("Body.create")]),t._v("创建并传递时，顶点会相对于"),v("code",[t._v("body.position")]),t._v("进行转换(即世界坐标，并在模拟过程中通过"),v("code",[t._v("Body.update")]),t._v("不断更新)。"),v("code",[t._v("Vector")]),t._v("对象还增加了有效碰撞检测所需的附加属性。"),v("br"),t._v(" 其他属性，如惯性和边界，会从传入的顶点自动计算(除非通过配置项设置了)。凹面目前不支持。"),v("code",[t._v("Matter.Vertices")]),t._v("模块包含了处理"),v("code",[t._v("vertices")]),t._v("的有用方法。")])])])]),t._v(" "),v("h2",{attrs:{id:"事件"}},[t._v("事件")]),t._v(" "),v("p",[t._v("以下事件均由"),v("code",[t._v("Matter.World.create")]),t._v("创建的对象派发，而后由使用"),v("code",[t._v("Matter.Events.on")]),t._v("订阅了事件的对象接收。")]),t._v(" "),v("h3",{attrs:{id:"events-on-body-sleepend-callback"}},[t._v('Events.on(body, "sleepEnd", callback)')]),t._v(" "),v("p",[t._v("当物体结束睡眠时触发(其中"),v("code",[t._v("this")]),t._v("指物体)。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("payload")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("类型")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("event")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Object")]),t._v(" "),v("td",[v("strong",[v("code",[t._v("source")])]),t._v(" "),v("br"),t._v(" 事件的源对象 "),v("br"),t._v(" "),v("strong",[v("code",[t._v("name")])]),t._v(" "),v("br"),t._v(" 事件名称")])])])]),t._v(" "),v("h3",{attrs:{id:"events-on-body-sleepstart-callback"}},[t._v('Events.on(body, "sleepStart", callback)')]),t._v(" "),v("p",[t._v("当物体开始睡眠时触发(其中"),v("code",[t._v("this")]),t._v("指物体)。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("payload")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("类型")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("event")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Object")]),t._v(" "),v("td",[v("strong",[v("code",[t._v("source")])]),t._v(" "),v("br"),t._v(" 事件的源对象 "),v("br"),t._v(" "),v("strong",[v("code",[t._v("name")])]),t._v(" "),v("br"),t._v(" 事件名称")])])])])])}),[],!1,null,null,null);e.default=d.exports}}]);